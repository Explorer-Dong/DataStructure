> $\mathscr {score:}$
>
> - 平时 20%（出勤、作业、实验）
> - 期中 20%
> - 期末 60%

## 一、绪论

### 1.1 数据分析+结构存储+算法计算

#### 1.1.1 逻辑结构

> 对于当前的数据之间的关系进行分析，进而思考应该如何存储

- 集合
- 线性结构
- 树形结构
- 图结构

#### 1.1.2 存储结构

> 设计一定的方法存储到程序中

- 存储内容
    - 数值存储
    - 数据与数据之间关系域的存储
- 存储方式
    - 顺序存储
    - 链式存储
    - 树形存储
    - 图存储

#### 1.1.3 算法实现

> 设计算法计算实现

### 1.2 数据类型

约束：值集 + 运算集

数据类型 $Data\ Type$（DT）：一般编程语言已经实现好了

抽象数据类型 $Abstract\ Data\ Type$（ADT）：数据结构+算法操作

### 1.3 算法

1. 正确性

2. ==健壮性（鲁棒性）==：对于不合法、异常的输入也有处理能力

3. 可读性

4. 可修改可扩展性

5. 高效率

    1. 空间复杂度

    2. 时间复杂度 $T(n)=O(f(n))$，其中有三种表示时间复杂度的公式

       > 1. 多项式级
       > 2. 指数级
       > 3. ...

        - $O()$ `upper bound`：最坏的时间复杂度
        - $\Omega()$ `lower bound`：最好的时间复杂度
        - $\Theta()$ `average bound`：平均时间复杂度

## 二、线性表

<img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20230920231245137.png" alt="image-20230920231245137" style="zoom:50%;" />

### 2.1 线性表的基本概念~(逻辑结构)~

有一个头结点，尾结点，且每一个结点只有一个前驱结点和一个后继结点。

### 2.2 线性表的存储结构

#### 2.2.1 顺序存储结构

存储在一维地址连续的存储单元里

特点：逻辑位置相邻，物理位置也相邻

数据结构：一个一个一维数组 + 一个长度变量 n

```c++
template<class T, int MaxSize>
class SeqList
{
    T data[MazSize];
    int length;
public:
    ...
}
```

> 顺序表可以直接存储*元素*与*关系*
>
> 链表的元素存储也是可以直接实现的，但是关系要通过*指正域*来实现

#### 2.2.2 链式存储结构

1. 单链表

   默认有一个头结点，不存储数据

2. 循环链表

3. 双向链表

### 2.3 线性表的操作算法

#### 2.3.1 顺序表的操作算法

1. 顺序表初始化构造

    - 无参构造
    - 有参构造

2. 求顺序表长度

3. 按位查找

4. 按值查找

5. 遍历顺序表

6. 插入

    - 在哪插入？

    - 插完之后会不会超过顺序表规定的最大内存？

    - 后移操作

    - 插入新元素、表长+1

    - ```c++
       template<class T, int MaxSize>
       void SeqList<T, MaxSize>::Insery(int i, int item)
       {
           if () {}
           if () {}
           for () {}
           length ++;
       }
     ```

7. 删除

    - 删哪个？

    - 是空表吗？

    - 前移

    - 表长-1

    - ```c++
       template<class T, int MaxSize>
       void SeqList<T, MaxSize>::Delete(int i, int item)
       {
           if
           if
           for
           length --;
       }
     ```

#### 2.3.2 链表的操作算法

1. 单链表初始化构造

    ```c++
    head = new Node<T>;
    head->next = nullptr;
    ```

    - 头插法

        ```c++
        head = new Node<T>;
        head->next = nullptr;
        ```

    - 尾插法

        ```c++
        head = new Node<T>;
        rear = head;
        ```

2. 求单链表长度

3. 按位查找

   扫描完毕之后，指针非空并且计数器不能大于pos，前者防止pos过大，后者防止pos过小（小于0）

4. 按值查找

5. 遍历单链表

6. 插入

7. 删除

8. 单链表的析构函数

9. 其他操作

10. 双向链表操作

    - 插入

        <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20230925092012868.png" alt="image-20230925092012868" style="zoom:50%;" />

        ```c++
        // 插入当前结点 s
        s->prior = p;
        s->next = p->next;
        p->next->prior = s;
        p->next = s;
        ```

    - 删除

        <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20230925091955866.png" alt="image-20230925091955866" style="zoom:50%;" />

        ```c++
        // 删除当前结点 p
        p->next->prior = p->prior;
        p->prior->next = p->next;
        ```

### 2.4 线性表的应用

### 2.5 顺序表和链表的综合比较

## 三、栈和队列

### 3.1 栈

#### 3.1.1 栈的基本概念

![image-20230928095521363](C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20230928095521363.png)

卡特兰数：假设 $f(k)$ 表示第k个数最后一个出栈的总个数，则 $f(k)=f(k-1)f(n-k)$
$$
f(n) = \sum_{k=1}^{n} f(k-1) f(n-k)=\frac{1}{n+1} C_{2n}^{n}
$$

#### 3.1.2 栈的存储结构

1. 顺序存储

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20230928095919380.png" alt="image-20230928095919380" style="zoom:67%;" />

2. 链式存储

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20230928100849337.png" alt="image-20230928100849337" style="zoom:67%;" />

#### 3.1.3 栈的操作算法

1. 顺序栈的操作
2. 链栈的操作

#### 3.1.4 栈的应用

1. 括号匹配

2. 算数表达式求值

    - 中缀表达式求值（算符优先法）

      **双栈**思路

    - 后缀表达式求值

      数栈即可

    - 中缀表达式转后缀表达式

      后缀先遇到的运算符先算 $\to$ 中缀表达式需要先算的运算符，于是转化思路就是：
      遇到操作数直接构造后缀表达式，如果是运算符，如果此时的运算符不需要计算，则继续，如果需要计算，就把当前的运算符构造后缀表达式

3. 栈与递归

   递归工作栈

### 3.2 队列

#### 3.2.1 队列的基本概念

先进先出

#### 3.2.2 队列的存储结构

1. 顺序存储

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231007091939711.png" alt="image-20231007091939711" style="zoom:67%;" />

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231007091951161.png" alt="image-20231007091951161" style="zoom:67%;" />

2. 链式存储

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231007090752380.png" alt="image-20231007090752380" style="zoom:67%;" />

#### 3.2.3 队列的操作算法

1. 循环队列的操作

   > ==循环队列的三个注意点==
   >
   > - 解决假溢出：采用循环队列，即在入队的时候不是单纯的指针+1，而是+1后%MaxSize
   > - 解决队空队满的冲突（真溢出）：
       >     1. 浪费一个元素空间：测试rear+1是否==head，
       >     2. 设置一个辅助标志变量
   >     3. 设置一个计数器

    1. 初始化：头尾全部初始化为0
    2. 入队push
    3. 出队pop
    4. 取队头front
    5. 长度size
    6. 队空empty

2. 链队列的操作

#### 3.2.4 队列的应用

1. 报数问题：报到0的出队，报到1的重新入队，输出出队顺序

2. 迷宫最短路问题：开一个记忆数组 $d[i][j]$ 表示从起点 $(0,0)$ 到终点 $(i,j)$ 点的**最短路径的长度**。可以将求最短路看做一个==波心扩散==的物理场景，队列中的每一个点都可以作为一个波心，从而实现“两点之间线段最短”的物理场景

    - 为什么用队列：逐层搜索，每次搜素到的点就是当前点可以搜索到的最短的点，先搜到的点先扩展，于是就是队列的数据结构
    - 为什么最短：对于每一个点探索到的点都是最短的点，最终的搜索出来的路径就是最短的路径

   算法思路：

## 四、串

### 4.1 串的基本概念

由字符组成的串

- 子串（连续）
- 主串
- 位置

### 4.2 串的存储结构

#### 4.2.1 串的顺序存储

使用固定长度的数组来存储，3种存储字符串长度的方法如下：

1. <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231012095542232.png" alt="image-20231012095542232" style="zoom:50%;" />

    ```c++
    struct String {
        char data[MaxSize];
        int Size;
    }
    ```



2. <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231012095512268.png" alt="image-20231012095512268" style="zoom:50%;" />

3. <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231012095528625.png" alt="image-20231012095528625" style="zoom:50%;" />

#### 4.2.2 串的链式存储

$$
存储密度 = \frac {串值所占的内存}{一个结点的总内存}
$$

1. 非压缩形式：一个结点存一个字符

    ```c++
    // 存储密度为：1/9 （64位操作系统）
    struct String {
        char data;
        String* next;
    };
    ```

2. 压缩形式（块链）：一个结点存储指定长度的字符

    ```c++
    // 存储密度为：4/12 （64位操作系统）
    const int MaxSize = 4;
    struct String {
        char data[MaxSize];
        String* next;
    }
    ```

### 4.3 串的操作算法

#### 4.3.1 串的基本操作算法

1. 串连接
2. 串比较
3. 串拷贝

#### 4.3.2 串的模式匹配

1. BF算法（Brute - Force）

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231012105536936.png" alt="image-20231012105536936" style="zoom:60%;" />

    ```c++
    // 返回匹配上的所有位置下标（下标从0开始）
    vector<int> BF(string& s, string& t) {
    	vector<int> res;
    	int i = 0, j = 0;
    	int n = s.size(), m = t.size();
    	while (i < n && j < m) {
    		if (s[i] == t[j]) {
    			i++, j++;
    		} else {
    			i = i - j + 1, j = 0;
    		}
    		if (j == m) {
    			res.emplace_back(i - j);
    			j = 0;
    		}
    	}
    	return res;
    }
    ```

2. KMP算法

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231012194432323.png" alt="image-20231012194432323" style="zoom:80%;" />

   > ==优化思想：==
   >
   > 先看暴力思想，我们需要每次将模式串t后移一位重新进行比较，其中浪费了已匹配的串数据，优化就是从这块已匹配的串数据入手。
   >
   > 而已匹配的串数据就是模式串本身的串数据，因为我们可以直接从模式串本身入手。
   >
   > ==初步猜想：==
   >
   > 根据模式串的性质，构造一个数表`next`，存储模式串应该后移的指针数k。
   >
   > ==算法实现：==
   >
   > 1. 递推求`next`数组
   > 2. KMP中`i`指针不回溯，`j`回溯到`next[j]`

    ```c++
    abczag c
    // 下标从0开始
        
        
    // 下标从1开始
    ```



#### 4.3.3 串的应用



## 五、数组和特殊矩阵

### 5.1 数组

#### 5.1.1 数组的基本概念

```c++
typedef int arr[m][n];
// 等价于
typedef int arr1[n];
typedef arr1 arr2[m];
```

#### 5.1.2 数组的存储结构

1. 行优先：按行存储
2. 列优先：按列存储

可以按照下标的关系，只需要知道第一个元素的地址，通过矩阵的大小关系即可直接计算出 $a_{ij\cdots}$ 的地址

### 5.2 特殊矩阵的压缩存储

对于多个相同的非零元素只分配一个存储空间，对零元素不分配空间

#### 5.2.1 对称矩阵的压缩存储

<img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231016092313887.png" alt="image-20231016092313887" style="zoom:50%;" />

假设现在有一个n*n的==对称矩阵：方阵元素关于主对角线相等==

存：行优先存储`data[n * (n + 1) / 2]`

取：我们如果要取`data[i][j]`

- 对于上三角

    - `i >= j`：`data[i * (i + 1) / 2 + j]`

    - `i < j`：`data[j * (j + 1) / 2 + i]`

- 对于下三角

    - `i >= j`：`data[i * (i + 1) / 2 + j]`

    - `i < j`：`data[j * (j + 1) / 2 + i]`

#### 5.2.2 三角矩阵的压缩存储

<img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231019094830937.png" alt="image-20231019094830937" style="zoom:50%;" />

假设现在有一个n*n的==三角矩阵：上三角或下三角为常数c==

存：行优先存储，常数c存储到最后`data[n * (n + 1) / 2 + 1]`

取：我们如果要取`data[i][j]`

- 对于上三角
    - `i <= j`：
    - `i < j`：
- 对于下三角
    - `i <= j`：
    - `i > j`：

#### 5.2.3 对角矩阵的压缩存储

<img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231019094859766.png" alt="image-20231019094859766" style="zoom:50%;" />

假设现在有一个n*n的==对角矩阵：围绕主对角线有数据，其余数据均为0==

存：行优先存储（或者对角线顺序），常数c存储到最后`data[n * (n + 1) / 2 + 1]`

取：我们如果要取`data[i][j]`

- 对于上三角
    - `i <= j`：
    - `i < j`：
- 对于下三角
    - `i <= j`：
    - `i > j`：

> 思考：已知k，如何知道i和j？

#### 5.2.4 稀疏矩阵的压缩存储

假设现在有一个n*m的==稀疏矩阵：很多零的一个矩阵==

1. 三元组顺序表

   按行存储两个信息，一个是非零元素的数值，还有一个是具体的坐标`(i, j)`

    ```c++
    class SparseMatrix {
        // 矩阵转置
        // 矩阵乘法
        // 矩阵加法
        // 矩阵打印
    };
    ```

    - 朴素矩阵转置

      列优先转置即可表示为行优先

    - 快速矩阵转置

      `cpot[i] = cpot[i - 1] + cnum[i - 1]`

2. 十字链表

   定义两个指针数组，定义两个指针数组，存储行列的头指针即可`vector<CrossNode<T>*> cheads, rheads`

    ```c++
    class CrossMatrix {
        // 矩阵转置
        // 矩阵乘法
        // 矩阵加法
        // 矩阵打印
    };
    ```

## 六、广义表

### 6.1 广义表的概念

- 与以往的线性表的区别在于：线性表的元素只能是DT或ADT，而对于广义表，元素还可以是一个广义表。即可递归结构
- 表头、表尾：对于当前序列，第一个元素就是表头，其余元素的集合就是表尾
- 特点：层次结构、共享结构、递归结构

### 6.2 广义表的存储结构

#### 6.2.1 广义表中结点的结构

采用联合结构体存储结点类型

<img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231023084427729.png" alt="image-20231023084427729" style="zoom:50%;" />

#### 6.2.2 广义表的存储结构

==流程图==

<img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231023090301534.png" alt="image-20231023090301534" style="zoom: 67%;" />

<center>类框架</center>

<img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231026104401429.png" alt="image-20231026104401429" style="zoom:50%;" />

<img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231026104417995.png" alt="image-20231026104417995" style="zoom:50%;" />

### 6.3 广义表的操作算法

- 直接递归法 - 原子直接操作，子表循环成原子进行操作
- 减治法 - 先处理第一个元素（==原子：直接操作== $or$ ==子表：递归操作==），最后递归操作剩余的元素

#### 6.3.1 构造算法



#### 6.3.2 遍历广义表



#### 6.3.3 广义表的其他操作算法

1. 复制广义表
2. 计算广义表的长度
3. 计算广义表的深度 - 原子深度为0，空表深度为1
4. 释放广义表的存储空间

## 七、树和二叉树

### 7.1 树的概念和性质

#### 7.1.1 树的定义



#### 7.1.2 树的基本术语

1. 结点的度和树的度
    - 结点的度：每一个结点孩子结点的数量
    - 树的度：一棵树中结点度数的最大值
2. 孩子、双亲、兄弟结点
3. 路径和路径长度
4. 子孙结点和祖先结点
5. 结点的层次和树的高度
6. 有序树和无序树
    - 有序树：子集不可以随意交换
    - 无序树：子集可以随意交换
7. 森林
    - 多棵树

#### 7.1.3 树的基本性质

### 7.2 二叉树的概念和性质

#### 7.2.1 二叉树的定义



#### 7.2.2 二叉树的基本性质

1. 根是第一层。第 $i$ 层最多有 $2^{i - 1}$ 个结点

2. 树中叶子结点的个数为 $n_0$，度数为2的结点的个数为 $n_2$。已知树的点数为 $n$，边数为 $m$，则 $n = m + 1$。而 $n=n_0+n_1+n_2$，$m=n_1+2n_2$，则 $n_0+n_1+n_2 = n_1+2n_2 +1$，则
   $$
   n_0=n_2 + 1
   $$

3. 满二叉树：每一层都是满结点

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231030085031394.png" alt="image-20231030085031394" style="zoom: 50%;" />

4. 完全二叉树：对于一个 $k$ 层的二叉树，$1\to k-1$ 都是满的，第 $k$ 层从左到右连接叶子结点

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231030085057862.png" alt="image-20231030085057862" style="zoom:50%;" />

   结点数固定，则完全二叉树的形状唯一

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231030090400650.png" alt="image-20231030090400650" style="zoom:67%;" />

   若 $i$ 为奇数，且 $i\neq1$，则左兄弟就是 $i-1$

   若 $i$ 为偶数，则右兄弟就是 $i+1$

### 7.3 二叉树的存储结构



#### 7.3.1 二叉树的顺序存储结构

- 对于一般的二叉树，将其转化为完全二叉树进行存储即可
- 插入删除操作都不方便

#### 7.3.2 二叉树的链式存储结构





### 7.4 二叉树的遍历

#### 7.4.1 二叉树遍历的概念



#### 7.4.2 二叉树遍历算法

1. 先中后遍历
    1. 递归遍历
    2. 栈式遍历 ==TODO==
2. 层序遍历

#### 7.4.3 二叉树的构造和析构

1. 由单个遍历序列构造二叉树

   可以从遍历的逻辑进行逆推。在遍历到空指针的时候输出一个编制符号，然后在构造的时候按照遍历序列进行递归构造即可，如图

   **先序序列**进行构造：==TODO==

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231102112448133.png" alt="image-20231102112448133" style="zoom:75%;" />

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231102112515427.png" alt="image-20231102112515427" style="zoom:75%;" />

   **中序序列**进行构造：

    <center>不可以，因为不能确定根节点以及左子树和右子树的部分</center>

   **后序序列**进行构造：==TODO==



2. 由两个遍历序列构造二叉树

   先+中

   后+中

3. 拷贝构造

4. 析构

5. 由顺序结构构造链式结构

### 7.5 二叉树的其他操作算法

1. 计算二叉树的结点数
    - 有返回值的递归
    - 无返回值的递归
2. 计算二叉树的高度
    - 有返回值的递归
    - 无返回值的递归
3. 根据关键值查找结点
4. 查找结点的父结点

### 7.6 线索二叉树

#### 7.6.1 线索二叉树的概念

将空指针域用前驱 or 后继结点的地址进行覆盖

#### 7.6.2 线索二叉树的存储结构

#### 7.6.3 线索二叉树的操作算法

> 中序线索化的二叉树

1. 线索化算法

   设置一个全局变量 pre，为了简化思维，我们可以将一个中序遍历的过程想象成一个线性结构。前驱为pre，当前为p。

    - p的左子树为空，则p的前驱为pre
    - pre的右子树为空，则pre的后继为p

2. 求后继结点和前驱结点的算法



3. 遍历算法



4. 求父结点的算法

    - 首先，若已知当前是左子树，则父结点一定是当前右孩子的中序前驱线索；若已知当前是右子树，则父结点一定是当前左孩子的中序前驱线索
    - 但是在未知当前结点的位置（未知左右子树）时，同时搜索两边的父结点，然后根据试探出来的父结点，特判父结点的子结点是否是当前结点即可

### 7.7 树的存储结构与算法

#### 7.7.1 树的存储结构

1. 多叉链表表示法

   将每一个结点的子结点都预设置为一个定值（树的最大度数）：浪费空间

2. 孩子链表表示法

   自顶向下存储边的信息

    ```c++
    template<class T>
    struct CTBox {
        T data;
        CTNode* firstchild;
    };
    struct CTNode {
        int child;
        CTNode* next;
    };
    ```

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231109115729850.png" alt="image-20231109115729850" style="zoom:50%;" />

3. 双亲表示法

   自下向上存储边的信息

    ```c++
    
    ```

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231109115759641.png" alt="image-20231109115759641" style="zoom:50%;" />

4. 孩子兄弟表示法

   左结点存储孩子，右结点存储兄弟

#### 7.7.2 树的操作算法

1. 构造
2. 高度
3. 计算树中所有结点的度

### 7.8 哈夫曼树与哈夫曼编码

#### 7.8.1 哈夫曼树的定义

树的路径长度：叶子结点到根结点的路径之和

1. 树的带权路径长度 $WPL$ ：叶子结点到根结点的路径之和 $\times$ 叶子结点的权重，整体之和
2. $WPL$ 最小的树就叫做哈夫曼树：对于一个结点序列n，每次选择其中的两个权值最小的两个结点进行合并，在进行了n-1次以后，得到的二叉树就是哈夫曼树
3. 哈夫曼编码：
    - 编码：利用二叉树进行前缀编码 - 避免解码时的二义性
    - 解码：根据编码的二叉trie树，进行解码

#### 7.8.2 哈夫曼树的构造

1. 构造算法
2. 存储结构
3. 构造函数

### 7.9 等价类问题

## 八、图

### 8.1 图的基本概念

#### 8.1.1 图的定义

$$
Graph = (V,E)
$$

完全无向图：edge=n(n-1)/2

完全有向图：edge=n(n-1)

#### 8.1.2 图的基本术语

- 带权图称为网

- 连通图和连通分量：

    - **无向图**

    - 连通图：每一个顶点之间都有路径可达
    - 连通分量：极大连通子图

- 强连通图和强连通分量：

    - **有向图**

    - 强连通图：每一个顶点之间都有路径可达
    - 强连通分量：极大强连通子图

### 8.2 图的存储结构

> 教材中的点编号统一从 $0$ 开始

#### 8.2.1 邻接矩阵表示法

- 无向图的度：第 $i$ 行（列）的非标记数的个数

- 有向图的度：

    - 入度：第 $i$ 行的非标记数的个数
    - 出度：第 $i$ 列的非标记数的个数

- 类定义：

    <img src="https://s2.loli.net/2023/11/23/bR61nTfc34wNVgH.png" alt="image-20231123111517468" style="zoom:67%;" />

    <img src="https://s2.loli.net/2023/11/23/O3HzLeM87SyUqN6.png" alt="image-20231123111541444" style="zoom:67%;" />

#### 8.2.2 邻接表表示法

- 存储出边表（邻接表）

- 存储入编表（逆邻接表）

- 类定义：

    <img src="https://s2.loli.net/2023/11/23/g5Hw6kdlGj8XvfQ.png" alt="image-20231123113744911" style="zoom:67%;" />

### 8.3 图的遍历

#### 8.3.1 图遍历的概念



8.3.2

## 九、查找



## 十、排序















