> $\mathscr {score:}$
>
> - 平时 20%（出勤、作业、实验）
> - 期中 20%
> - 期末 60%

## 一、绪论

### 1.1 数据分析+结构存储+算法计算

#### 1.1.1 逻辑结构

> 对于当前的数据之间的关系进行分析，进而思考应该如何存储

- 集合
- 线性结构
- 树形结构
- 图结构

#### 1.1.2 存储结构

> 设计一定的方法存储到程序中

- 存储内容
    - 数值存储
    - 数据与数据之间关系域的存储
- 存储方式
    - 顺序存储
    - 链式存储
    - 树形存储
    - 图存储

#### 1.1.3 算法实现

> 设计算法计算实现

### 1.2 数据类型

约束：值集 + 运算集

数据类型 $Data\ Type$（DT）：一般编程语言已经实现好了

抽象数据类型 $Abstract\ Data\ Type$（ADT）：数据结构+算法操作

### 1.3 算法

1. 正确性

2. ==健壮性（鲁棒性）==：对于不合法、异常的输入也有处理能力

3. 可读性

4. 可修改可扩展性

5. 高效率

    1. 空间复杂度

    2. 时间复杂度 $T(n)=O(f(n))$，其中有三种表示时间复杂度的公式

       > 1. 多项式级
       > 2. 指数级
       > 3. ...

        - $O()$ `upper bound`：最坏的时间复杂度
        - $\Omega()$ `lower bound`：最好的时间复杂度
        - $\Theta()$ `average bound`：平均时间复杂度

## 二、线性表

<img src="https://s2.loli.net/2023/12/04/4Nn73PGspUM2Cwl.png" alt="image-20230920231245137" style="zoom:50%;" />

### 2.1 线性表的基本概念~(逻辑结构)~

有一个头结点，尾结点，且每一个结点只有一个前驱结点和一个后继结点。

### 2.2 线性表的存储结构

#### 2.2.1 顺序存储结构

存储在一维地址连续的存储单元里

特点：逻辑位置相邻，物理位置也相邻

数据结构：一个一个一维数组 + 一个长度变量 n

```c++
template<class T, int MaxSize>
class SeqList
{
    T data[MazSize];
    int length;
public:
    ...
}
```

> 顺序表可以直接存储*元素*与*关系*
>
> 链表的元素存储也是可以直接实现的，但是关系要通过*指正域*来实现

#### 2.2.2 链式存储结构

1. 单链表

   默认有一个头结点，不存储数据

2. 循环链表

3. 双向链表

### 2.3 线性表的操作算法

#### 2.3.1 顺序表的操作算法

1. 顺序表初始化构造

    - 无参构造
    - 有参构造

2. 求顺序表长度

3. 按位查找

4. 按值查找

5. 遍历顺序表

6. 插入

    - 在哪插入？

    - 插完之后会不会超过顺序表规定的最大内存？

    - 后移操作

    - 插入新元素、表长+1

    - ```c++
       template<class T, int MaxSize>
       void SeqList<T, MaxSize>::Insery(int i, int item)
       {
           if () {}
           if () {}
           for () {}
           length ++;
       }
     ```

7. 删除

    - 删哪个？

    - 是空表吗？

    - 前移

    - 表长-1

    - ```c++
       template<class T, int MaxSize>
       void SeqList<T, MaxSize>::Delete(int i, int item)
       {
           if
           if
           for
           length --;
       }
     ```

#### 2.3.2 链表的操作算法

1. 单链表初始化构造

    ```c++
    head = new Node<T>;
    head->next = nullptr;
    ```

    - 头插法

        ```c++
        head = new Node<T>;
        head->next = nullptr;
        ```

    - 尾插法

        ```c++
        head = new Node<T>;
        rear = head;
        ```

2. 求单链表长度

3. 按位查找

   扫描完毕之后，指针非空并且计数器不能大于pos，前者防止pos过大，后者防止pos过小（小于0）

4. 按值查找

5. 遍历单链表

6. 插入

7. 删除

8. 单链表的析构函数

9. 其他操作

10. 双向链表操作

    - 插入

        <img src="https://s2.loli.net/2023/12/04/7d4ygetnDPANTzU.png" alt="image-20230925092012868" style="zoom:50%;" />

        ```c++
        // 插入当前结点 s
        s->prior = p;
        s->next = p->next;
        p->next->prior = s;
        p->next = s;
        ```

    - 删除

        <img src="https://s2.loli.net/2023/12/04/CiJzh1HXaGqvURB.png" alt="image-20230925091955866" style="zoom:50%;" />

        ```c++
        // 删除当前结点 p
        p->next->prior = p->prior;
        p->prior->next = p->next;
        ```

### 2.4 线性表的应用

### 2.5 顺序表和链表的综合比较

## 三、栈和队列

### 3.1 栈

#### 3.1.1 栈的基本概念

![image-20230928095521363](https://s2.loli.net/2023/12/04/MuQ7ZHX6xNKSqbf.png)

卡特兰数：假设 $f(k)$ 表示第k个数最后一个出栈的总个数，则 $f(k)=f(k-1)f(n-k)$
$$
f(n) = \sum_{k=1}^{n} f(k-1) f(n-k)=\frac{1}{n+1} C_{2n}^{n}
$$

#### 3.1.2 栈的存储结构

1. 顺序存储

    <img src="https://s2.loli.net/2023/12/04/DGIASXO27NbC8Ji.png" alt="image-20230928095919380" style="zoom:67%;" />

2. 链式存储

    <img src="https://s2.loli.net/2023/12/04/o8mYC2XQvqUJ5BL.png" alt="image-20230928100849337" style="zoom:67%;" />

#### 3.1.3 栈的操作算法

1. 顺序栈的操作
2. 链栈的操作

#### 3.1.4 栈的应用

1. 括号匹配

2. 算数表达式求值

    - 中缀表达式求值（算符优先法）

      **双栈**思路

    - 后缀表达式求值

      数栈即可

    - 中缀表达式转后缀表达式

      后缀先遇到的运算符先算 $\to$ 中缀表达式需要先算的运算符，于是转化思路就是：
      遇到操作数直接构造后缀表达式，如果是运算符，如果此时的运算符不需要计算，则继续，如果需要计算，就把当前的运算符构造后缀表达式

3. 栈与递归

   递归工作栈

### 3.2 队列

#### 3.2.1 队列的基本概念

先进先出

#### 3.2.2 队列的存储结构

1. 顺序存储

    <img src="https://s2.loli.net/2023/12/04/GJh3alEndfXKCMq.png" alt="image-20231007091939711" style="zoom:67%;" />

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231007091951161.png" alt="image-20231007091951161" style="zoom:67%;" />

2. 链式存储

    <img src="https://s2.loli.net/2023/12/04/h1rZ6A3FVN9mRaq.png" alt="image-20231007090752380" style="zoom:67%;" />

#### 3.2.3 队列的操作算法

1. 循环队列的操作

   > ==循环队列的三个注意点==
   >
   > - 解决假溢出：采用循环队列，即在入队的时候不是单纯的指针+1，而是+1后%MaxSize
   > - 解决队空队满的冲突（真溢出）：
       >     1. 浪费一个元素空间：测试rear+1是否==head，
       >     2. 设置一个辅助标志变量
   >     3. 设置一个计数器

    1. 初始化：头尾全部初始化为0
    2. 入队push
    3. 出队pop
    4. 取队头front
    5. 长度size
    6. 队空empty

2. 链队列的操作

#### 3.2.4 队列的应用

1. 报数问题：报到0的出队，报到1的重新入队，输出出队顺序

2. 迷宫最短路问题：开一个记忆数组 $d[i][j]$ 表示从起点 $(0,0)$ 到终点 $(i,j)$ 点的**最短路径的长度**。可以将求最短路看做一个==波心扩散==的物理场景，队列中的每一个点都可以作为一个波心，从而实现“两点之间线段最短”的物理场景

    - 为什么用队列：逐层搜索，每次搜素到的点就是当前点可以搜索到的最短的点，先搜到的点先扩展，于是就是队列的数据结构
    - 为什么最短：对于每一个点探索到的点都是最短的点，最终的搜索出来的路径就是最短的路径

   算法思路：

## 四、串

### 4.1 串的基本概念

由字符组成的串

- 子串（连续）
- 主串
- 位置

### 4.2 串的存储结构

#### 4.2.1 串的顺序存储

使用固定长度的数组来存储，3种存储字符串长度的方法如下：

1. <img src="https://s2.loli.net/2023/12/04/lwkEMtF2mXjPpaz.png" alt="image-20231012095542232" style="zoom:50%;" />

    ```c++
    struct String {
        char data[MaxSize];
        int Size;
    }
    ```



2. <img src="https://s2.loli.net/2023/12/04/vbFg17sAwLBModl.png" alt="image-20231012095512268" style="zoom:50%;" />

3. <img src="https://s2.loli.net/2023/12/04/DIQATWxkN5J3eH1.png" alt="image-20231012095528625" style="zoom:50%;" />

#### 4.2.2 串的链式存储

$$
存储密度 = \frac {串值所占的内存}{一个结点的总内存}
$$

1. 非压缩形式：一个结点存一个字符

    ```c++
    // 存储密度为：1/9 （64位操作系统）
    struct String {
        char data;
        String* next;
    };
    ```

2. 压缩形式（块链）：一个结点存储指定长度的字符

    ```c++
    // 存储密度为：4/12 （64位操作系统）
    const int MaxSize = 4;
    struct String {
        char data[MaxSize];
        String* next;
    }
    ```

### 4.3 串的操作算法

#### 4.3.1 串的基本操作算法

1. 串连接
2. 串比较
3. 串拷贝

#### 4.3.2 串的模式匹配

1. BF算法（Brute - Force）

    <img src="https://s2.loli.net/2023/12/04/NemPEzIdOpLh3Vb.png" alt="image-20231012105536936" style="zoom:60%;" />

    ```c++
    // 返回匹配上的所有位置下标（下标从0开始）
    vector<int> BF(string& s, string& t) {
    	vector<int> res;
    	int i = 0, j = 0;
    	int n = s.size(), m = t.size();
    	while (i < n && j < m) {
    		if (s[i] == t[j]) {
    			i++, j++;
    		} else {
    			i = i - j + 1, j = 0;
    		}
    		if (j == m) {
    			res.emplace_back(i - j);
    			j = 0;
    		}
    	}
    	return res;
    }
    ```

2. KMP算法

    <img src="https://s2.loli.net/2023/12/04/X2VvgtLuKnH1NwJ.png" alt="image-20231012194432323" style="zoom:80%;" />

   > ==优化思想：==
   >
   > 先看暴力思想，我们需要每次将模式串t后移一位重新进行比较，其中浪费了已匹配的串数据，优化就是从这块已匹配的串数据入手。
   >
   > 而已匹配的串数据就是模式串本身的串数据，因为我们可以直接从模式串本身入手。
   >
   > ==初步猜想：==
   >
   > 根据模式串的性质，构造一个数表`next`，存储模式串应该后移的指针数k。
   >
   > ==算法实现：==
   >
   > 1. 递推求`next`数组
   > 2. KMP中`i`指针不回溯，`j`回溯到`next[j]`

    ```c++
    abczag c
    // 下标从0开始
        
        
    // 下标从1开始
    ```



#### 4.3.3 串的应用



## 五、数组和特殊矩阵

### 5.1 数组

#### 5.1.1 数组的基本概念

```c++
typedef int arr[m][n];
// 等价于
typedef int arr1[n];
typedef arr1 arr2[m];
```

#### 5.1.2 数组的存储结构

1. 行优先：按行存储
2. 列优先：按列存储

可以按照下标的关系，只需要知道第一个元素的地址，通过矩阵的大小关系即可直接计算出 $a_{ij\cdots}$ 的地址

### 5.2 特殊矩阵的压缩存储

对于多个相同的非零元素只分配一个存储空间，对零元素不分配空间

#### 5.2.1 对称矩阵的压缩存储

<img src="https://s2.loli.net/2023/12/04/TKBNSHyJ7RcdFu3.png" alt="image-20231016092313887" style="zoom:50%;" />

假设现在有一个n*n的==对称矩阵：方阵元素关于主对角线相等==

存：行优先存储`data[n * (n + 1) / 2]`

取：我们如果要取`data[i][j]`

- 对于上三角

    - `i >= j`：`data[i * (i + 1) / 2 + j]`

    - `i < j`：`data[j * (j + 1) / 2 + i]`

- 对于下三角

    - `i >= j`：`data[i * (i + 1) / 2 + j]`

    - `i < j`：`data[j * (j + 1) / 2 + i]`

#### 5.2.2 三角矩阵的压缩存储

<img src="https://s2.loli.net/2023/12/04/6OPLDYtrKld1iGv.png" alt="image-20231019094830937" style="zoom:50%;" />

假设现在有一个n*n的==三角矩阵：上三角或下三角为常数c==

存：行优先存储，常数c存储到最后`data[n * (n + 1) / 2 + 1]`

取：我们如果要取`data[i][j]`

- 对于上三角
    - `i <= j`：
    - `i < j`：
- 对于下三角
    - `i <= j`：
    - `i > j`：

#### 5.2.3 对角矩阵的压缩存储

<img src="https://s2.loli.net/2023/12/04/PwcA7Tu5XBZ2q8y.png" alt="image-20231019094859766" style="zoom:50%;" />

假设现在有一个n*n的==对角矩阵：围绕主对角线有数据，其余数据均为0==

存：行优先存储（或者对角线顺序），常数c存储到最后`data[n * (n + 1) / 2 + 1]`

取：我们如果要取`data[i][j]`

- 对于上三角
    - `i <= j`：
    - `i < j`：
- 对于下三角
    - `i <= j`：
    - `i > j`：

> 思考：已知k，如何知道i和j？

#### 5.2.4 稀疏矩阵的压缩存储

假设现在有一个n*m的==稀疏矩阵：很多零的一个矩阵==

1. 三元组顺序表

   按行存储两个信息，一个是非零元素的数值，还有一个是具体的坐标`(i, j)`

    ```c++
    class SparseMatrix {
        // 矩阵转置
        // 矩阵乘法
        // 矩阵加法
        // 矩阵打印
    };
    ```

    - 朴素矩阵转置

      列优先转置即可表示为行优先

    - 快速矩阵转置

      `cpot[i] = cpot[i - 1] + cnum[i - 1]`

2. 十字链表

   定义两个指针数组，定义两个指针数组，存储行列的头指针即可`vector<CrossNode<T>*> cheads, rheads`

    ```c++
    class CrossMatrix {
        // 矩阵转置
        // 矩阵乘法
        // 矩阵加法
        // 矩阵打印
    };
    ```

## 六、广义表

### 6.1 广义表的概念

- 与以往的线性表的区别在于：线性表的元素只能是DT或ADT，而对于广义表，元素还可以是一个广义表。即可递归结构
- 表头、表尾：对于当前序列，第一个元素就是表头，其余元素的集合就是表尾
- 特点：层次结构、共享结构、递归结构

### 6.2 广义表的存储结构

#### 6.2.1 广义表中结点的结构

采用联合结构体存储结点类型

<img src="https://s2.loli.net/2023/12/04/Gjiltk6f74yO5L9.png" alt="image-20231023084427729" style="zoom:50%;" />

#### 6.2.2 广义表的存储结构

==流程图==

<img src="https://s2.loli.net/2023/12/04/G9yUhn4mzEDPBxo.png" alt="image-20231023090301534" style="zoom: 67%;" />

<center>类框架</center>

<img src="https://s2.loli.net/2023/12/04/cvPKiCE1xTB24MW.png" alt="image-20231026104401429" style="zoom:50%;" />

<img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231026104417995.png" alt="image-20231026104417995" style="zoom:50%;" />

### 6.3 广义表的操作算法

- 直接递归法 - 原子直接操作，子表循环成原子进行操作
- 减治法 - 先处理第一个元素（==原子：直接操作== $or$ ==子表：递归操作==），最后递归操作剩余的元素

#### 6.3.1 构造算法



#### 6.3.2 遍历广义表



#### 6.3.3 广义表的其他操作算法

1. 复制广义表
2. 计算广义表的长度
3. 计算广义表的深度 - 原子深度为0，空表深度为1
4. 释放广义表的存储空间

## 七、树和二叉树

### 7.1 树的概念和性质

#### 7.1.1 树的定义



#### 7.1.2 树的基本术语

1. 结点的度和树的度
    - 结点的度：每一个结点孩子结点的数量
    - 树的度：一棵树中结点度数的最大值
2. 孩子、双亲、兄弟结点
3. 路径和路径长度
4. 子孙结点和祖先结点
5. 结点的层次和树的高度
6. 有序树和无序树
    - 有序树：子集不可以随意交换
    - 无序树：子集可以随意交换
7. 森林
    - 多棵树

#### 7.1.3 树的基本性质

### 7.2 二叉树的概念和性质

#### 7.2.1 二叉树的定义



#### 7.2.2 二叉树的基本性质

1. 根是第一层。第 $i$ 层最多有 $2^{i - 1}$ 个结点

2. 树中叶子结点的个数为 $n_0$，度数为2的结点的个数为 $n_2$。已知树的点数为 $n$，边数为 $m$，则 $n = m + 1$。而 $n=n_0+n_1+n_2$，$m=n_1+2n_2$，则 $n_0+n_1+n_2 = n_1+2n_2 +1$，则
   $$
   n_0=n_2 + 1
   $$

3. 满二叉树：每一层都是满结点

    <img src="https://s2.loli.net/2023/12/04/dECpXhRImnJHxiw.png" alt="image-20231030085031394" style="zoom: 50%;" />

4. 完全二叉树：对于一个 $k$ 层的二叉树，$1\to k-1$ 都是满的，第 $k$ 层从左到右连接叶子结点

    <img src="https://s2.loli.net/2023/12/04/2xWt4QInCRXKulf.png" alt="image-20231030085057862" style="zoom:50%;" />

   结点数固定，则完全二叉树的形状唯一

    <img src="https://s2.loli.net/2023/12/04/qDFBM34ghjwkCzR.png" alt="image-20231030090400650" style="zoom:67%;" />

   若 $i$ 为奇数，且 $i\neq1$，则左兄弟就是 $i-1$

   若 $i$ 为偶数，则右兄弟就是 $i+1$

### 7.3 二叉树的存储结构



#### 7.3.1 二叉树的顺序存储结构

- 对于一般的二叉树，将其转化为完全二叉树进行存储即可
- 插入删除操作都不方便

#### 7.3.2 二叉树的链式存储结构





### 7.4 二叉树的遍历

#### 7.4.1 二叉树遍历的概念



#### 7.4.2 二叉树遍历算法

1. 先中后遍历
    1. 递归遍历
    2. 栈式遍历 ==TODO==
2. 层序遍历

#### 7.4.3 二叉树的构造和析构

1. 由单个遍历序列构造二叉树

   可以从遍历的逻辑进行逆推。在遍历到空指针的时候输出一个编制符号，然后在构造的时候按照遍历序列进行递归构造即可，如图

   **先序序列**进行构造：==TODO==

    <img src="C:/Users/%E8%91%A3%E6%96%87%E6%9D%B0/AppData/Roaming/Typora/typora-user-images/image-20231102112448133.png" alt="image-20231102112448133" style="zoom:75%;" />

    <img src="https://s2.loli.net/2023/12/04/EIX38hF67pVitun.png" alt="image-20231102112515427" style="zoom:75%;" />

   **中序序列**进行构造：

    <center>不可以，因为不能确定根节点以及左子树和右子树的部分</center>

   **后序序列**进行构造：==TODO==



2. 由两个遍历序列构造二叉树

   先+中

   后+中

3. 拷贝构造

4. 析构

5. 由顺序结构构造链式结构

### 7.5 二叉树的其他操作算法

1. 计算二叉树的结点数
    - 有返回值的递归
    - 无返回值的递归
2. 计算二叉树的高度
    - 有返回值的递归
    - 无返回值的递归
3. 根据关键值查找结点
4. 查找结点的父结点

### 7.6 线索二叉树

#### 7.6.1 线索二叉树的概念

将空指针域用前驱 or 后继结点的地址进行覆盖

#### 7.6.2 线索二叉树的存储结构

#### 7.6.3 线索二叉树的操作算法

> 中序线索化的二叉树

1. 线索化算法

   设置一个全局变量 pre，为了简化思维，我们可以将一个中序遍历的过程想象成一个线性结构。前驱为pre，当前为p。

    - p的左子树为空，则p的前驱为pre
    - pre的右子树为空，则pre的后继为p

2. 求后继结点和前驱结点的算法



3. 遍历算法



4. 求父结点的算法

    - 首先，若已知当前是左子树，则父结点一定是当前右孩子的中序前驱线索；若已知当前是右子树，则父结点一定是当前左孩子的中序前驱线索
    - 但是在未知当前结点的位置（未知左右子树）时，同时搜索两边的父结点，然后根据试探出来的父结点，特判父结点的子结点是否是当前结点即可

### 7.7 树的存储结构与算法

#### 7.7.1 树的存储结构

1. 多叉链表表示法

   将每一个结点的子结点都预设置为一个定值（树的最大度数）：浪费空间

2. 孩子链表表示法

   自顶向下存储边的信息

    ```c++
    template<class T>
    struct CTBox {
        T data;
        CTNode* firstchild;
    };
    struct CTNode {
        int child;
        CTNode* next;
    };
    ```

    <img src="https://s2.loli.net/2023/12/04/eKfb6koTwzBUAOV.png" alt="image-20231109115729850" style="zoom:50%;" />

3. 双亲表示法

   自下向上存储边的信息

    ```c++
    
    ```

    <img src="https://s2.loli.net/2023/12/04/Pc4ZMp2eQE1aCfN.png" alt="image-20231109115759641" style="zoom:50%;" />

4. 孩子兄弟表示法

   左结点存储孩子，右结点存储兄弟

#### 7.7.2 树的操作算法

1. 构造
2. 高度
3. 计算树中所有结点的度

### 7.8 哈夫曼树与哈夫曼编码

#### 7.8.1 哈夫曼树的定义

树的路径长度：叶子结点到根结点的路径之和

1. 树的带权路径长度 $WPL$ ：叶子结点到根结点的路径之和 $\times$ 叶子结点的权重，整体之和
2. $WPL$ 最小的树就叫做哈夫曼树：对于一个结点序列n，每次选择其中的两个权值最小的两个结点进行合并，在进行了n-1次以后，得到的二叉树就是哈夫曼树
3. 哈夫曼编码：
    - 编码：利用二叉树进行前缀编码 - 避免解码时的二义性
    - 解码：根据编码的二叉trie树，进行解码

#### 7.8.2 哈夫曼树的构造

1. 构造算法
2. 存储结构
3. 构造函数

### 7.9 等价类问题

## 八、图

### 8.1 图的基本概念

#### 8.1.1 图的定义

$$
Graph = (V,E)
$$

完全无向图：edge=n(n-1)/2

完全有向图：edge=n(n-1)

#### 8.1.2 图的基本术语

- 带权图称为网

- 连通图和连通分量：

    - **无向图**

    - 连通图：每一个顶点之间都有路径可达
    - 连通分量：极大连通子图

- 强连通图和强连通分量：

    - **有向图**

    - 强连通图：每一个顶点之间都有路径可达
    - 强连通分量：极大强连通子图

### 8.2 图的存储结构

> 教材中的点编号统一从 $0$ 开始

#### 8.2.1 邻接矩阵表示法

- 无向图的度：第 $i$ 行（列）的非标记数的个数

- 有向图的度：

    - 入度：第 $i$ 行的非标记数的个数
    - 出度：第 $i$ 列的非标记数的个数

- 类定义：

    <img src="https://s2.loli.net/2023/11/23/bR61nTfc34wNVgH.png" alt="image-20231123111517468" style="zoom:67%;" />

    <img src="https://s2.loli.net/2023/11/23/O3HzLeM87SyUqN6.png" alt="image-20231123111541444" style="zoom:67%;" />

#### 8.2.2 邻接表表示法

- 存储出边表（邻接表）

- 存储入编表（逆邻接表）

- 类定义：

    <img src="https://s2.loli.net/2023/11/23/g5Hw6kdlGj8XvfQ.png" alt="image-20231123113744911" style="zoom:67%;" />

### 8.3 图的遍历

#### 8.3.1 图遍历的概念

每个结点只能访问一次

#### 8.3.2 深度优先搜索

<img src="https://s2.loli.net/2023/12/04/hXzEj7fZQqrJl3u.png" alt="image-20231127083412848" style="zoom:67%;" />

1. 邻接矩阵：

    - 时间复杂度：$O(n^2)$

    - 针对**邻接矩阵**的一个**无向**连通图的搜索代码示例

        <img src="https://s2.loli.net/2023/12/04/IqEmULWtYw5Chv9.png" alt="image-20231127083039909" style="zoom:67%;" />

2. 邻接表：

    - 时间复杂度：$O(n+e)$

    - 针对**邻接表**的一个**无向**连通图的搜索代码示例

        ```c++
        template<class T>
        void ALGraph::DFS(int v, bool* visited) {
            cout << vexs[v];
            visited[v] = true;
            // 遍历所有的边
        }
        ```

#### 8.3.3 广度优先搜索

- 通过队列实现
- 时间复杂度与上述DFS算法类似

#### 8.3.4 图遍历算法的应用

1. 求 `(u,v)` 的所有简单路径

    > dfs+回溯法的简单应用

2. 染色法求二部图

    > bfs的简单应用

### 8.4 最小生成树

#### 8.4.1 最小生成树的概念及其性质

$Minimum\ Spanning\ Tree(MST)$

证明：

<img src="https://s2.loli.net/2023/11/30/YjIDAz6dsPUbTOB.png" alt="image-20231130114331973" style="zoom: 67%;" />

对于上述的一个割，选择其中权值最小的交叉边。从而对于所有的状态，每次选择最小交叉边即可。

#### 8.4.2 Prim算法

算法标签：$greedy$

- 构造 $n-1$ 个割的状态
- 起始状态为：顶点集合 $U$ 含 $1$ 个顶点，顶点集合 $V-U$ 含 $n-1$ 个顶点
- 状态转移为：
    - 选完最小交叉边之后，将这条边在集合 $V-U$ 中的顶点加入到最小生成树集合 $U$ 中
    - 更新最小交叉边数组 $miniedges[\ ]$

- 时间复杂度：$O(n^2)$

#### 8.4.3 Kruskal算法

算法流标签：$greedy、dsu$

- 初始化 $n$ 个顶点作为 $n$ 个连通分量
- 按照边的权值升序进行选择
    - 如果选出的边的两个顶点不在同一个集合，则加入最小生成树
    - 如果选出的边的两个顶点在同一个集合，则不选择（如果选了就会使得生成树形成回路）
- 时间复杂度：$O(e\log e)$

### 8.5 最短路径

#### 8.5.1 最短路径的概念

单源最短路

> $Dijkstra$ 算法无法求解含负边权的单源最短路
>
> $Bellman-Ford$ 算法支持负边权的单源最短路求解
>
> $Spfa$ 算法同样支持负边权的单元最短路，属于 $Bellman-Ford$ 算法的优化

多源最短路

> $Floyd$ 适用于求解含负边权的多源最短路

#### 8.5.2 单源最短路径 - $Dijkstra$ 算法

算法标签：$greedy$

> 其实就是 $Prim$ 的另一种应用
>
> - $Prim$ 是只存储交叉边的最小值
> - $Dijkstra$ 是存储交叉边的最小值 $+$ 这条边在集合S中的点已经记录的值

1. 朴素版：

    - 邻接矩阵
    - 定义 $d[i]$ 表示从起点到当前i号点的最短路径的长度

    - 将顶点分为两个集合，$S$ 和 $V-S$，其中 $S$ 表示已经更新了最短路径长度的顶点集合
    - 迭代更新过程：依次更新每一个结点，对于当前结点 $v_i$，在集合 $S$ 中的所有结点中，选择其中到当前结点路径最短的顶点 $v_j$，则 `d[i]=d[j]+edges[j][i]`

    - 时间复杂度：$O(n^2)$


2. 堆优化：

    - 邻接表

    - 时间复杂度：$O(e \log e)$


#### 8.5.3 多源最短路径 - $Floyd$ 算法

算法标签：$dp$

> 多阶段决策共 $n$ 个阶段，`dp[i][j]` 表示每一个阶段 $k$，从 $i$ 到 $j$ 的选择前 $k$ 个顶点后的最短路径的长度

对于当前阶段 $k$，我们利用阶段 $k-1$ 的状态进行转移更新，其实就是对于新增加的顶点 $v_k$ 是否选择的过程

- 选择 $v_k$，则 `dp[i][j] = dp[i][k] + dp[k][j]`
- 不选 $v_k$，则 `dp[i][j]` 就是 $k-1$ 状态下的 `dp[i][j]`

### 8.6 AOV网与拓扑排序

#### 8.6.1 有向无环图与AOV网的概念

- 有向无环图：$DAG$
- AOV网： $(activity\ on\ vertex\ network)$
- 应用场景：在时间先后上有约束关系的工程管理问题

#### 8.6.2 拓扑排序

- 定义：顶点线性化
- 应用：判环、判断一个图是否可以进行动态规划
- 算法设计：对于有向图，从所有的入度为0的点开始删点删边，到最后判断有多少点被删除即可
- 算法实现：可以采用dfs进行缩点删边，也可以采用bfs进行缩点删边
- 时间复杂度：$O(n+e)$

## 九、查找

### 9.1 静态查找表

定义：只支持查询和修改，不支持删除与插入

#### 9.1.1 顺序查找

#### 9.1.2 折半查找

#### 9.1.3 分块查找

结合顺序查找与分块查找的一种方法

图例：<img src="https://s2.loli.net/2023/12/25/dkaKtQWFMbAR2Hh.png" alt="image-20231225093347357" style="zoom:67%;" />

- 索引表可以折半或者顺序查找
- 块内部只能顺序查找

### 9.2 动态查找表



### 9.3 Hash 查找

定义：装填因子 $\alpha=\frac{n}{m}$，其中 $n$ 表示待填入表中的结点数，$m$ 表示哈希表的空间大小

哈希函数应该满足以下两点：第一、映射出来的地址不会越界；第二、映射出来的地址是唯一的

#### 9.3.1 构造表

**常用的哈希函数**

1. 直接地址法 - 线性函数一对一映射

    优点。计算简单且不可能产生冲突

    缺点。对于空间的要求极高，如果数据过于离散，则会造成很大的空间浪费

2. 数字分析法 - 按照数位中的数值分布情况进行哈希

    缺点。需要预先知道数据的数字分布情况

3. 平方取中法 - 对于 $10^m$ 的哈希空间，可以将数字平方后取中间 $m$ 位进行哈希存储

4. 折叠法

    - 移位法：将一个数字按照数位拆分为几个部分，然后将几个部分的数值累加出一个数即可，高位抹去不用

    - 间隔法：与移位法几乎一致，只不过将其中的部分意义间隔的进行数值反转，最后累计即可，高位抹去不用

5. 除留余数法 - 按照数值 $\text{mod}\ p$ 后的数值进行哈希，假设哈希表空间大小为 $m$ ，则 $p$ 一般取 $\le m$ 的质数

**处理冲突**

1. 开放定址法 - 探测开放地址，一般有三种
    - 连续序列进行线性探测
    - 左右倍增序列进行探测
    - 伪随机序列进行探测
2. 拉链法

#### 9.3.2 查找表

## 十、排序

### 10.1 排序的基本概念

关键字：

- 主关键字：每一个待排序的该关键字是独一无二的
- 次关键字：每一个待排序的该关键字可能是重复的

稳定性：

- 场景：只针对次关键字的情况
- 稳定：按照次关键字排序后，原来相同关键字的顺序不变
- 不稳定：按照次关键字排序后，原来相同关键字的顺序可能会改变

内外排序：

- 内排序：数据全部存放在内存
- 外排序：数据量过大时，待排序的数据在内存与外存之间不断转换

### 10.2 冒泡排序:star:

基于交换的思路进行

**稳定的**

### 10.3 选择排序:star:

- 选择第 1 小的数放在第一个位置，...，选择第 i 小的数放在第 i 个位置

- 共选择 n-1 次

### 10.4 插入排序:star:

- 直接插入排序：依次向前缀已经排好序的序列中进行插入 - $O(n^2)$
- 折半插入排序：同上，只是选择插入位置的使用二分 - $O(n\log n)$
- 递归插入排序：排序 `[1,i]` 等价于先排好 `[1,i-1]`，然后插入当前 `num[i]` 即可

**稳定的**

### 10.5 希尔排序:star:

基于插入直接排序的优点：

1. 当序列基本有序时，效率很高
2. 当待排序数很少时，效率很高

于是希尔（Shell）就得出来以下的希尔排序算法：

1. 将序列划分一定次数，从 d<n 到 1
2. 每次划分都对组内的元素进行直接插入排序
3. 最后分为 1 组时，直接排序一趟以后就可以得到 sortrd sequence

**不稳定**

**稳定的**

### 10.6 快速排序:star:

分治法三步骤：divide、conquer and combine

每次选择一个 pivot 进行 partition，递归两个 partition

```c++
void Sort(int l, int r) {
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = a[l + r >> 1];
    while (i < j) {
        while (a[i] < x) i++;
        while (a[j] > x) j++;
        if (i < j) swap(a[i], a[j]);            
    }
    Sort(l, j), Sort(j + 1, r);
}
```

**不稳定**

### 10.7 堆排序:star:

- $k_i \le k_{2i}\ \&\&\ k_i \le k_{2i+1}$ 叫做 小顶堆

- $k_i \ge k_{2i}\ \&\&\ k_i \ge k_{2i+1}$ 叫做 大顶堆

建立初始堆

> 从第一个非叶子结点开始建堆，对每一个元素与左孩子与右孩子进行比较
>
> - 如果当前结点的值比左右孩子都大，那么无需修改，当前位置就是堆顶
> - 如果当前结点的值比左孩子或者右孩子中的最大值小，则将最大的孩子作为堆顶，并将当前值不断的“下沉”即可

交换堆顶与记录位置后重新建堆

> 交换记录值以后，需要将除了已记录的值的结点以外的所有结点重新建堆
>
> - 建堆过程与上述初始建堆的过程完全一致，只是结点数每次 -1

时间复杂度 $O(n \log n)$

**不稳定**

### 10.8 归并排序:star:

递归

> 同样采用分治法，我们按照分治法的三个步骤进行讨论
>
> - divide: 将当前序列划分为左右两部分
> - conquer: 递归处理上述划分出来的两部分
> - combine: 归并上述递归完的两部分
>
> 时间复杂度 $O(n \log n)\leftarrow T(n)=2T(\frac{n}{2}) + O(n)$

非递归

> 就是模拟上述递归的过程，可以拆分为三步
>
> - 归并
> - 按照指定的长度处理整个序列
> - 划分局部排序的长度

**稳定的**

### 10.9 基数排序













