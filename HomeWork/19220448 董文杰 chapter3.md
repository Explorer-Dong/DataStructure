## 作业

### T1

> 编号为1、2、3、4、5的五辆列车，顺序开进一个栈式结构的站点，问开出车站的顺序有多少种可能？请具体写出所有可能的出栈序列。

首先根据卡特兰公式可以直接计算出总方案数：
$$
\frac{1}{n+1} C_{2n}^{n} = \frac{1}{5+1} C_{10}^{5} = 42
$$
接下来我们编程求解所有具体的方案。对于一辆车，只有两种状态：

- 在车站内，此时可以出站，也可以不出站
- 在车站外，此时可以进站，也可以不进站

我们利用深度优先搜索解决这个问题，代码如下：

```cpp
void testCatlan() {
    SeqStack<int, 100> station;
    vector<int> out;
    int n = 5;
    get_train_seq(station, out, n);
}

void get_train_seq(SeqStack<int, 100>& station, vector<int>& out, int n) {
    /**
     * @note get all the train sequence
     * @param station train station
     * @param out the train sequence
     * @param n the number of the train
     */

    if (out.size() == 5) {
        // all the train has been out
        for (int i = 0; i < out.size(); i++) {
            cout << out[i] << " \n"[i == out.size() - 1];
        }
        return;
    }

    if (n > 0) {
        // condition 1: there are trains not in the station, push the train into the station
        station.Push(n);
        get_train_seq(station, out, n - 1);
        station.Pop();
    }

    if (!station.Empty()) {
        // condition 2: there are trains in the station, pop the train out
        int train = station.Top();
        station.Pop();
        out.push_back(train);
        get_train_seq(station, out, n);
        out.pop_back();
        station.Push(train);
    }
}
```

最终可以得到下面的运行结果，刚好 42 种方案：

```makefile
1 2 3 4 5
2 1 3 4 5
2 3 1 4 5
2 3 4 1 5
2 3 4 5 1
3 1 2 4 5
3 2 1 4 5
3 2 4 1 5
3 2 4 5 1
3 4 1 2 5
3 4 2 1 5
3 4 2 5 1
3 4 5 1 2
3 4 5 2 1
4 1 2 3 5
4 2 1 3 5
4 2 3 1 5
4 2 3 5 1
4 3 1 2 5
4 3 2 1 5
4 3 2 5 1
4 3 5 1 2
4 3 5 2 1
4 5 1 2 3
4 5 2 1 3
4 5 2 3 1
4 5 3 1 2
4 5 3 2 1
5 1 2 3 4
5 2 1 3 4
5 2 3 1 4
5 2 3 4 1
5 3 1 2 4
5 3 2 1 4
5 3 2 4 1
5 3 4 1 2
5 3 4 2 1
5 4 1 2 3
5 4 2 1 3
5 4 2 3 1
5 4 3 1 2
5 4 3 2 1
```

### T2

> 利用栈实现把十进制整数转换为二至十六之间的任一进制数输出的功能。

取余再相除即可。

```cpp
void testConvert() {
    int num, base;
    cin >> num >> base;

    SeqStack<int, 100> a;
    while (num >= base) {
        int mod = num % base;
        a.Push(mod);
        num = (num - mod) / base;
    }
    a.Push(num);

    while (!a.Empty()) {
        int t = a.Top();
        a.Pop();
        if (t < 10) {
            cout << t;
        } else {
            cout << (char)('A' + t - 10);
        }
    }
}
```

### T3

> 假设表达式中允许包含3种括号：圆括号、方括号和大括号。试编写一个算法，检查表达式中括号是否配对，若能够全部配对则返回1，否则返回0。

扫描表达式即可。匹配逻辑为：遇到数字或运算符则直接略过，遇到左括号则入栈，遇到右括号则进行匹配的判断。最后需要检查括号栈中是否为空，防止有多余的左括号。时间复杂度 $O(n)$

```cpp
bool testMatch(std::string s = "{10+9*12+[10/(2+90)+1]*(1+2)}") {
    SeqStack<char, 100> a;
    string op = "{[()]}";
    int i = 0;

    while (i < s.size()) {
        if (isdigit(s[i]) || op.find(s[i]) == string::npos) {
            // skip numbers or operators
            i++;
        } else if (s[i] == '{' || s[i] == '[' || s[i] == '(') {
            // left bracket
            a.Push(s[i++]);
        } else {
            // right bracket
            if (a.Empty()) {
                // too many right brackets
                return false;
            } else if (s[i] == '}' && a.Top() == '{' ||
                       s[i] == ']' && a.Top() == '[' ||
                       s[i] == ')' && a.Top() == '(') {
                a.Pop();
                i++;
            } else {
                // mismatch
                return false;
            }
        }
    }

    return a.Empty();
}
```

### T4

> 设有一维数组stack[StackMaxSize]，分配给两个栈S1和S2使用，如何分配数组空间，使得对任何一个栈，当且仅当数组空间全满时才不能插入。试说明你的分配方法。并分别给出两个栈各自的入栈和出栈算法。

借鉴双端队列 `deque` 的思路，我们使用双端栈。即数组**左端**实现一个栈的压入与弹出，数组**右端**实现另一个栈的压入与弹出。通过**双指针**进行内存空间的动态调度。设计一个双端栈来实现双栈的压入、弹出算法。

类声明

```cpp
template<class T, int MaxSize>
class SeqDoubleStack {
private:
    T data[MaxSize];
    int l, r;

public:
    SeqDoubleStack() : l(-1), r(MaxSize) {}
    void Push_front(T x);
    T Pop_front();
    void Push_back(T x);
    T Pop_back();
    void Output();
};
```

左入栈

```cpp
template<class T, int MaxSize>
void SeqDoubleStack<T, MaxSize>::Push_front(T x) {
    if (l + 1 == r) {
        cerr << "full size" << endl;
        exit(1);
    }
    data[++l] = x;
}
```

左出栈

```cpp
template<class T, int MaxSize>
T SeqDoubleStack<T, MaxSize>::Pop_front() {
    if (l == -1) {
        cerr << "empty left stack" << endl;
        exit(1);
    }
    T now = data[l--];
    return now;
}
```

右入栈

```cpp
template<class T, int MaxSize>
void SeqDoubleStack<T, MaxSize>::Push_back(T x) {
    if (l + 1 == r) {
        cerr << "full size" << endl;
        exit(1);
    }
    data[--r] = x;
}
```

右出栈

```cpp
template<class T, int MaxSize>
T SeqDoubleStack<T, MaxSize>::Pop_back() {
    if (r == MaxSize) {
        cerr << "empty right stack" << endl;
        exit(1);
    }
    T now = data[r++];
    return now;
}
```


### T5

> 现有中缀表达式 $E=((A-B)/C+D*(E-F))*G$ （注：此题在纸上练习，不用提交）
>
> 1. 写出与 E 等价的后缀表达式。
> 2. 用一个操作符栈来模拟表达式的转换过程，画出在将 E 转换成后缀表达式的过程中，栈内容的变化图。
> 3. 用一个操作数栈来模拟后缀表达式的求值过程，画出对（2）中所得到的后缀表达式求值时，栈中内容的变化图。

1. 根据中缀表达式画出一棵表达式树之后，后序遍历一遍就是后缀表达式。当然用栈其实就是存储「模拟递归」过程中的操作数和操作符。
2. **中缀表达式转后缀表达式**。这需要我们了解中缀表达式和后缀表达式的构造和解析的逻辑。在后缀表达式的解析过程中，我们一旦遇到操作符就需要进行运算，这恰恰对应了中缀表达式的构造过程中，遇到右括号或比较操作符优先级时进行运算的过程。因此我们可以利用构造中缀表达式的过程构造出后缀表达式。即：当中缀遇到操作数时构造后缀的操作数，当中缀进行运算时构造后缀的操作符即可。
3. **后缀表达式求值**。此时只需要一个操作数栈即可，因为后缀的顺序为「左操作数+右操作数+操作符」，并不需要额外的容器存储操作符，遇到操作数直接入栈，遇到操作符直接取两个操作数进行运算，再将运算结果压入操作数栈即可。

中缀表达式求值的具体解析可见这篇博客：[AcWing 3302. 表达式求值 | 原理解析 - AcWing](https://www.acwing.com/file_system/file/content/whole/index/content/12197289/)

### T6

> 假设以带头结点的循环链表表示队列，并且只设一个表尾指针，试编写相应的置队列空、入队和出队操作。

含头结点且只有一个尾指针的循环链式队列

声明列表

```cpp
template<class T>
class LinkQueue {
private:
	Node<T>* rear;

public:
	LinkQueue();
	~LinkQueue();
	void Clear();
	void Push(T x);
	T Pop();
};
```

置空

```cpp
template<class T>
void LinkQueue<T>::Clear() {
	// 0个结点
	if (!rear->next) {
		cerr << "空队列，无法清空" << "\n";
		exit(1);
	}
	// 释放除了尾结点以外的所有的结点
	Node<T>* hh = rear->next;
	while (hh->next != rear) {
		Node<T>* front = hh->next;
		hh = front->next;
		delete front;
	}
	// 释放最后一个结点
	Node<T>* last = rear;
	rear = hh;
	hh->next = nullptr;
	delete last;
}
```

入队

```cpp
template<class T>
void LinkQueue<T>::Push(T x) {
	Node<T>* now = new Node<T>(x);
	// 区分首次入队
	Node<T>* hh = nullptr;
	if (!rear->next) {
		hh = rear;
	} else {
		hh = rear->next;
	}
	rear->next = now;
	rear = now;
	now->next = hh;
}
```

出队

```cpp
template<class T>
T LinkQueue<T>::Pop() {
	if (!rear->next) {
		cerr << "下溢" << "\n";
		exit(1);
	}
	Node<T>* hh = rear->next;
	Node<T>* front = hh->next;
	T res = front->data;
	if (front->next == hh) { // 弹出最后一个结点的情况，置空用来进行健壮性编写
		rear = hh;
		hh->next = nullptr;
	} else {
		hh->next = front->next;
		delete front;
	}
	return res;
}
```

### T7

> 假设以一维数组data[m]存储循环队列的元素，若要使这m个分量都得到应用，则另设一辅助标志变量flag判断队列的状态为“空”还是“满”。编写入队和出队算法。

设置辅助变量的循环顺序队列

声明列表

```cpp
template<class T, int MaxSize>
class SeqQueueFlag
{
private:
	T data[MaxSize];
	int front, rear;
	bool flag;

public:
	SeqQueue();
	void Push(T x);
	T Pop();
	T Front();
	bool Empty();
};
```

入队

```cpp
template<class T, int MaxSize>
void SeqQueueFlag<T, MaxSize>::Push(T x) {
	if (flag) {
		cerr << "队满" << "\n";
		exit(1);
	}
	data[rear] = x;
	rear = (rear + 1) % MaxSize;
	if (rear == front) {
		flag = true;
	}
}
```

出队

```cpp
template<class T, int MaxSize>
T SeqQueueFlag<T, MaxSize>::Pop() {
	if (rear == front && !flag) {
		cerr << "队空" << "\n";
		exit(1);
	}
	T res = data[front];
	front = (front + 1) % MaxSize;
	if (flag) {
		flag = false;
	}
	return res;
}
```

### T8

> 假设以一维数组data[m]存放循环队列的元素，同时设变量num表示当前队列中元素的个数，以判断队列的状态为“空”还是“满”。试给出此循环队列满的条件，并编写入队和出队算法。

设置记录元素个数的循环顺序队列

判断队列满

```cpp
num == MaxSize;
```

入队

```cpp
template<class T, int MaxSize>
void SeqQueueNum<T, MaxSize>::Push(T x) {
	if (num == MaxSize) {
		cerr << "队满" << "\n";
		exit(1);
	}
	data[rear] = x;
	num++;
	rear = (rear + 1) % MaxSize;
}
```

出队

```cpp
template<class T, int MaxSize>
T SeqQueueNum<T, MaxSize>::Pop() {
	if (!num) {
		cerr << "队空" << "\n";
		exit(1);
	}
	T res = data[front];
	front = (front + 1) % MaxSize;
	num--;
	return res;
}
```


### T9

> 如何用两个栈来实现队列？并写出队列基本操作的算法。

实现思路：假设我们现在有两个栈，分别为A、B

- 入队：首先将B栈元素依次弹出、压入A栈直到B栈为空；最后将新元素压入A栈
- 出队：首先将A栈元素依次弹出、压入B栈直到A栈为空；最后将B栈栈顶弹出即可

思路总结：假如只有一个A栈，我们想要实现先进先出就需要从栈底开始输出元素，但是显然不可以。于是此时再借助B栈就可以将所有的元素逆置，从而实现先进先出。

时间复杂度：$O(n^2)$

声明列表

```cpp
template<class T, int MaxSize>
class Dstack2Queue {
private:
	SeqStack<T, MaxSize> A;
	SeqStack<T, MaxSize> B;

public:
	Dstack2Queue() {}
	void Push(T x);
	T Pop();
	T Front();
	bool Empty();
};
```

入队

```cpp
template<class T, int MaxSize>
void Dstack2Queue<T, MaxSize>::Push(T x) {
	// 由于A和B栈已经有上溢的检查，所以这里不需要再检查
	while (!B.Empty()) {
		A.Push(B.Top());
		B.Pop();
	}
	A.Push(x);
}
```

出队

```cpp
    template<class T, int MaxSize>
    T Dstack2Queue<T, MaxSize>::Pop() {
    	while (!A.Empty()) {
    		B.Push(A.Top());
    		A.Pop();
    	}
    	if (B.Empty()) {
    		cerr << "队空" << "\n";
    		exit(1);
    	}
    	T res = B.Pop();
    	return res;
    }
```

取队头

```cpp
    template<class T, int MaxSize>
    T Dstack2Queue<T, MaxSize>::Front() {
    	while (!A.Empty()) {
    		B.Push(A.Top());
    		A.Pop();
    	}
    	if (B.Empty()) {
    		cerr << "队空" << "\n";
    		exit(1);
    	}
    	return B.Top();
    }
```

判空

```cpp
    template<class T, int MaxSize>
    bool Dstack2Queue<T, MaxSize>::Empty() {
    	return A.Empty() && B.Empty();
    }
```

## 实验

### T1

> 顺序栈的实现与应用。
>
> 1. 编写main()函数对class SeqStack进行测试，要求：使用菜单选择各项功能。
> 2. 利用顺序栈采用算符优先算法编程实现直接计算中缀表达式的值，要求：输入中缀算术表达式，计算表达式的值。
> 3. 利用顺序栈编程实现先将中缀表达式转换成后缀表达式，再计算后缀表达式的值。
>
> 扩展要求：请修改第（2）题中的中缀表达式求值算法，不仅可以对1位数的操作数进行算术运算，还可以对如下所示的更大的整数做计算：123-89*25-960



### T2

> 队列的实现与应用。
>
> 1. 编写main()函数对class SeqQueue进行测试，要求：使用菜单选择各项功能。
> 2. 编写一个程序，模拟患者在医院等待就诊的情况，主要模拟两件事：
>     1. 患者到达诊室，将病历交给护士，排到等待队列中候诊；
>     2. 护士从等待队列中取出下一位患者的病历，该患者进入诊室就诊。
>
> 程序采用菜单方式，其选项及功能说明如下：
>
> 1. 排队：输入排队患者的病历号（随机产生），加入到就诊患者排队队列中；
> 2. 就诊：患者队列中最前面的病人就诊，并将其从队列中删除；
> 3. 查看：从队首到队尾列出所有排队患者的病历号；
> 4. 下班：退出运行。



### T3

> 对一给定的迷宫，求其从入口到出口的最短路径。
