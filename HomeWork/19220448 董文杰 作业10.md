1. 设有整型数组 $x$，试编写算法：将负数集中在数组 $x$ 的一端，正数集中在数组 $x$ 的另一端。要求算法时间复杂性为 $O(n)$

    > 思路：双指针即可

    ```c++
    void clarify() {
        int n = 10;
        int x[10] = {-1, 4, 2, -3, -9, -10, 3, 5, -6, -7};
    
        int l = 0, r = n - 1;
        while (l < r) {
            while (x[l] < 0) l++;
            while (x[r] > 0) r--;
            if (l < r) swap(x[l], x[r]);
        }
    
        for (int i = 0; i < n; i++) {
            cout << x[i] << " \n"[i == n - 1];
        }
    }
    ```

2. 请给出快速排序的非递归的算法描述

    > 思路：
    >
    > - 我们先从递归的角度进行思考，在 $divide$ 时，就是一个简单的双指针进行一次 $partition$，$conquer$ 时就是对前面分出的两个部分进行继续 $partition$ 的过程，其中传递的参数为数组边界。由于在递归操作过程中，采用的类似于“前序遍历”的顺序，因此对于递归的子结构之间是独立相关的，正因为是独立相关的，所以子结构排好序之后，不会影响全局的排序情况且全局排好序！
    > - 因此栈模拟的思路就有了：我们只需要将每次 $partition$ 的左右边界存入栈即可

    ```c++
    void _QuickSort() {
        int n = 10;
        int x[10] = {-1, 4, 2, -3, -9, -10, 3, 5, -6, -7};
    
        auto partition = [&](int l, int r) {
            int i = l - 1, j = r + 1, m = x[(l + r) >> 1];
            while (i < j) {
                while (x[++i] < m);
                while (x[--j] > m);
                if (i < j) swap(x[i], x[j]);
            }
            return j;
        };
    
        struct board {
            int l, r;
        };
    
        stack<board> stk;
        stk.push({0, n - 1});
    
        while (stk.size()) {
            auto h = stk.top();
            stk.pop();
    
            int l = h.l, r = h.r;
            if (l >= r) continue;
    
            int j = partition(l, r);
    
            stk.push({l, j});
            stk.push({j + 1, r});
        }
    
        for (int i = 0; i < n; i++) {
            cout << x[i] << " \n"[i == n - 1];
        }
    }
    ```