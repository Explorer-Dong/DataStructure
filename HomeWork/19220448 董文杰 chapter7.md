## 作业七

### T1

> 若一棵 *m* 叉树中，度为1的结点有*N*1个，度为2的结点有*N*2个，……，度为*m*的结点有*Nm*个，问该树的叶子结点有多少个？

我们约定题中的度为出度，树的结点数为 $v$，边数为 $e$，则有关系式：
$$
v=e+1
$$
已知度 $\ge 1$ 的结点数 $\sum_{k=1}^m N_k$ ，则度为 $0$ 的叶子结点数 $N_0$ 为：
$$
\begin{aligned}
N_0&=v-\sum_{k=1}^m N_k\\
&= e+1-\sum_{k=1}^m N_k\\
&= \sum_{k=1}^m k\cdot N_k +1 - \sum_{k=1}^m N_k\\
&= \sum_{k=1}^m (k-1)\cdot N_k +1
\end{aligned}
$$
### T2

> 试找出分别满足下列条件的所有二叉树： （此题在纸上画，不用提交）
> （1）先序序列和中序序列相同；
> （2）中序序列和后序序列相同；
> （3）先序序列和后序序列相同。

这道题一开始可能没什么思路，也许可以随意画几个结点凑数，但是没有一般的结论。但我们从递归的角度思考本题也许会有不一样的发现。

对于一个二叉树，我们将其定义为「根、左子树、右子树」三个部分。则先序遍历是根左右，中序遍历是左根右，后序遍历是左右根。

于是对于上述三种问题，想要某种序列和另外一种序列相同，就是对应的三部分要相同。显然的只有根一定合法，但是如果左右子树同时存在就一定不可能合法，想要合法就只能删除子树，因此可得：

（1）先序 = 中序 $\to$ 根左右 = 左根右 $\to$ `根#右` = `#根右`

（2）中序 = 后序 $\to$ 左根右 = 左右根 $\to$ `左根#` = `左#根`

（3）先序 = 后序 $\to$ 根左右 = 左右根 $\to$ `根##` = `##根`

### T3

> 设有168个结点的完全二叉树，请问叶子结点、单分支结点、双分支结点各有多少个？

假设层数从 $0$ 开始，则当前完全二叉树共有 $\left \lceil \log_2(N+1) \right \rceil=8$ 层，即 $[0,7]$ 层中均有结点，其中：

- $[0, 6]$ 层是满二叉树，共 $2^{6+1}-1=127$ 个结点
- 第 $7$ 层有 $2^7=128$ 个位置。从左至右占用了 $168-127=41$ 个位置

于是可以计算出：

- 双分支结点为 $127-64+ \left \lfloor \frac{41}{2} \right \rfloor=83$ 个
- 单分支结点为 $41\%2=1$ 个
- 叶子结点为 $41+64-\left \lceil \frac{41}{2} \right \rceil=84$ 个

### T4

> 已知某二叉树的后序序列是*GEFCDBA*，中序序列是*AEGCFBD*，请画出该二叉树的二叉链表结构图，并写出先序遍历序列。

每次利用后序找到「根」将中序分解为左子树、根、右子树，然后递归分解左右子树即可。

<img src="https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202408081604470.png" alt="image-20231107144008995" style="zoom:15%;" />

### T5

> 试编写算法求二叉树中双分支节点的个数。

遍历每一个结点判断左右结点是否存在即可。时间复杂度 $O(n)$

```cpp

```

### T6

> 试编写算法求二叉树中各个结点的平衡因子（左右子树高度之差）

递归统计即可，返回形式为 `{ {data, height_sub}, {}, ..., {} }`。时间复杂度 $O(n)$

```cpp

```

### T7

> 一棵二叉树以二叉链表来表示，求其指定的某一层 $k(k>1)$ 上的叶子结点的个数。

遍历时增加参数为当前层数后哈希即可。时间复杂度 $O(n)$

```cpp

```

### T8

> 试编写算法输出一棵二叉树中根结点到各个叶子结点的路径。

遍历时记录路径，遇到叶子结点保存完整路径即可，需要在回溯时弹出遍历过的结点。时间复杂度 $O(n)$

```cpp

```

### T9

> 设计一个算法，求二叉树中两个给定结点的最近公共祖先。

方法一：**枚举**。我们可以利用 $T10$ 封装好的函数直接求解。即：求出根结点两个指定结点的路径，返回最右端的相同字符即可。注意需要修改一下 T10 的程序，即将下面的两行代码交换顺序。每次询问的时间复杂度 $O(n)$

改进：一步一步向上跳的过程可以采用递归枚举子树是否空的思路进行，如果匹配到了两个结点中的任意一个结点，就返回当前结点，反之则返回空指针。最后按照左右子树的返回值是否为空来进行判断。

```cpp

```

方法二：**树上倍增**。OJ：[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

> 题意：给定 $n$ 个结点，$m$ 次询问，问两个结点的最近公共祖先
>
> 思路：当然，求解 LCA 还有其他众多方法，目前只掌握了树上倍增的思路，相对于上述的对路径中所有结点逐个遍历，优化策略就是二进制遍历。当然前提是提前维护好了 `fa[i][j]` 数组，表示 $i$ 号点向上跳 $2^j$ 步后到达的结点。接着就是跳跃的过程了，我们首先需要将两个结点按照倍增的思路向上跳到同一个深度，接下来两个结点同时按照倍增的思路向上跳跃，为了确保求出最近的，我们需要确保在跳跃的步调一致的情况下，两者的祖先始终不相同，那么倍增结束后，两者的父结点就是最近公共祖先，即 `fa[x][k]` 或 `fa[y][k]`
>
> 维护 $fa$ 数组：可以发现，对于 `fa[i][j]`，我们可以通过递推的方式获得，即 `fa[i][j] = fa[fa[i][j-1]][j-1]`，当前结点向上跳跃 $2^j$ 步可以拆分为先向上 $2^{j-1}$ 步，在此基础之上再向上 $2^{j-1}$ 步。于是我们可以采用宽搜的顺序维护 $fa$ 数组。
>
> 时间复杂度：
>
> - 维护 $fa$ 数组时，对于树中的每一个结点，我们都要统计向上跳跃 $[0,\lg N]$ 的所有情况，故时间复杂度为 $O(n \log n)$
>- 跳跃时，每一次询问中，我们都需要对两个结点进行跳跃，时间复杂度是 $O(\log n)$，那么 $m$ 次询问的时间复杂度就是 $O(m\log n)$
> - 总时间复杂度就是：$O((n+m)\log n)$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 5e5 + 10;

int n, Q, root;
vector<int> G[N];
int fa[N][20], dep[N];
queue<int> q;

void bfs() {
	dep[root] = 1;
	q.push(root);

	while (q.size()) {
		int now = q.front();
		q.pop();
		for (int ch: G[now]) {
			if (!dep[ch]) {
				dep[ch] = dep[now] + 1;
				fa[ch][0] = now;
				for (int k = 1; k <= 19; k++) {
                    // 递推更新，从小到大枚举
					fa[ch][k] = fa[ fa[ch][k-1] ][k-1];
				}
				q.push(ch);
			}
		}
	}
}

int lca(int a, int b) {
	if (dep[a] < dep[b]) swap(a, b);

    // 二进制拼凑，从大到小枚举
	for (int k = 19; k >= 0; k--)
		if (dep[fa[a][k]] >= dep[b])
			a = fa[a][k];

	if (a == b) return a;

	for (int k = 19; k >= 0; k--)
		if (fa[a][k] != fa[b][k])
			a = fa[a][k], b = fa[b][k];

	return fa[a][0];
}

void solve() {
	cin >> n >> Q >> root;
	for (int i = 0; i < n - 1; ++i) {
		int a, b;
		cin >> a >> b;
		G[a].push_back(b);
		G[b].push_back(a);
	}

	bfs();

	while (Q--) {
		int a, b;
		cin >> a >> b;
		cout << lca(a, b) << "\n";
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	int T = 1;
//	cin >> T;
	while (T--) solve();
	return 0;
}
```

### T10

> 若一棵二叉树中没有数据域值相同的结点，试设计算法打印二叉树中数据域值为x的结点的所有祖先结点的数据域。如果根结点的数据域值为x或不存在数据域值为x的结点，则什么也不打印。例如对下图所示的二叉树，则打印结点序列为A、C、E。
>
> ![img](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202408081606053.png)

和 $T8$ 类似，只是标记点为指定的点而非叶子结点。时间复杂度 $O(n)$

```cpp

```

### T11

> 已知二叉树存于二叉链表中，试编写一个算法，判断给定二叉树是否为完全二叉树。

直接进行层序遍历，如果当前是叶结点，那么同一层的后面的结点都只能是叶结点。时间复杂度 $O(n)$

```cpp

```

### T12

> 已知二叉树存于二叉链表中，试编写一个算法计算二叉树的宽度，即同一层中结点数的最大值。

遍历统计即可，深搜宽搜均可实现，T7 用的是宽搜，这里就以深搜为例。时间复杂度 $O(n)$

```cpp

```

### T13

> 已知二叉树存于二叉链表中，编写一个递归算法，利用叶结点中空的右链指针域rchild，将所有叶结点自左至右链接成一个单链表，算法返回最左叶结点的地址（链头）

我们只需要设置一个头指针 `h` 和当前指针 `p`，在遍历二叉树的时候链接叶子结点即可。时间复杂度 $O(n)$

```cpp

```

## 实验七

### T1

![第七章实验 - 1](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202408081608105.png)



### T2

![第七章实验 - 2](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202408081608671.png)

### T3

![第七章实验 - 3](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202408081608481.png)
